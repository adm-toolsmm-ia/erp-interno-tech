---
globs: *.ts,*.tsx,*.js,*.jsx
description: "Padr√µes de seguran√ßa para o MVP do ERP"
---

# üîí ERP Security MVP ‚Äî ERPInternoTech

## Regras de Seguran√ßa MVP

### Autentica√ß√£o (Fase 2)
- **MVP**: Sem autentica√ß√£o implementada
- **Restri√ß√£o**: Uso interno apenas
- **Prepara√ß√£o**: Estrutura pronta para JWT/Supabase Auth

### Valida√ß√£o de Uploads
```typescript
// SEMPRE validar MIME type
const allowedMimeTypes = [
  'application/pdf',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'image/png',
  'image/jpeg'
];

function validateFileType(file: File): boolean {
  return allowedMimeTypes.includes(file.type);
}

// SEMPRE validar tamanho (50MB max)
function validateFileSize(file: File): boolean {
  return file.size <= 50 * 1024 * 1024; // 50MB
}
```

### Auditoria M√≠nima
```typescript
// SEMPRE logar opera√ß√µes cr√≠ticas
interface AuditLog {
  empresaId: string;
  userId?: string;
  action: string;
  resource: string;
  resourceId: string;
  ip?: string;
  userAgent?: string;
  timestamp: string;
}

function logAudit(audit: AuditLog) {
  console.log(JSON.stringify({
    level: 'audit',
    ...audit
  }));
}
```

### Valida√ß√£o de Dados
```typescript
// SEMPRE validar entrada
import { z } from 'zod';

const CreateProjetoSchema = z.object({
  empresaId: z.string().cuid(),
  clienteId: z.string().cuid(),
  assunto: z.string().min(1).max(255),
  dataEntrada: z.date(),
  expectativa: z.string().optional(),
  objetivo: z.string().optional()
});

// SEMPRE sanitizar dados
function sanitizeInput(input: string): string {
  return input
    .replace(/[<>]/g, '') // Remove caracteres perigosos
    .trim()
    .substring(0, 1000); // Limita tamanho
}
```

### Headers de Seguran√ßa
```typescript
// SEMPRE incluir headers de seguran√ßa
export function setSecurityHeaders(response: Response) {
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-XSS-Protection', '1; mode=block');
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
}
```

## Middleware de Seguran√ßa

### Valida√ß√£o de Tenant
```typescript
// middleware/tenant-validation.ts
export function validateTenant(empresaId: string, userEmpresaId: string): boolean {
  return empresaId === userEmpresaId;
}

// SEMPRE validar tenant em APIs
export async function GET(request: Request) {
  const empresaId = request.headers.get('x-empresa-id');
  const userEmpresaId = request.headers.get('x-user-empresa-id');
  
  if (!validateTenant(empresaId, userEmpresaId)) {
    return Response.json({ error: 'Unauthorized' }, { status: 403 });
  }
}
```

### Rate Limiting B√°sico
```typescript
// middleware/rate-limit.ts
const rateLimit = new Map<string, { count: number; resetTime: number }>();

export function rateLimitCheck(ip: string, limit: number = 100, windowMs: number = 60000): boolean {
  const now = Date.now();
  const key = ip;
  const current = rateLimit.get(key);
  
  if (!current || now > current.resetTime) {
    rateLimit.set(key, { count: 1, resetTime: now + windowMs });
    return true;
  }
  
  if (current.count >= limit) {
    return false;
  }
  
  current.count++;
  return true;
}
```

## Valida√ß√£o de Arquivos

### Upload Seguro
```typescript
// lib/upload-security.ts
export async function secureUpload(file: File, empresaId: string): Promise<string> {
  // 1. Validar tipo MIME
  if (!validateFileType(file)) {
    throw new Error('Tipo de arquivo n√£o permitido');
  }
  
  // 2. Validar tamanho
  if (!validateFileSize(file)) {
    throw new Error('Arquivo muito grande');
  }
  
  // 3. Gerar nome seguro
  const safeName = generateSafeFileName(file.name, empresaId);
  
  // 4. Upload para Supabase Storage
  const { data, error } = await supabase.storage
    .from(`empresa-${empresaId}`)
    .upload(safeName, file);
    
  if (error) throw error;
  
  return data.path;
}

function generateSafeFileName(originalName: string, empresaId: string): string {
  const timestamp = Date.now();
  const extension = originalName.split('.').pop();
  const safeName = originalName.replace(/[^a-zA-Z0-9.-]/g, '_');
  
  return `${empresaId}/${timestamp}-${safeName}`;
}
```

## Logs de Seguran√ßa

### Estrutura de Log
```typescript
interface SecurityLog {
  level: 'security';
  event: string;
  empresaId: string;
  userId?: string;
  ip?: string;
  userAgent?: string;
  details: Record<string, any>;
  timestamp: string;
}

function logSecurityEvent(event: string, details: Record<string, any>, request: Request) {
  const log: SecurityLog = {
    level: 'security',
    event,
    empresaId: request.headers.get('x-empresa-id') || 'unknown',
    userId: request.headers.get('x-user-id'),
    ip: request.headers.get('x-forwarded-for') || 'unknown',
    userAgent: request.headers.get('user-agent'),
    details,
    timestamp: new Date().toISOString()
  };
  
  console.log(JSON.stringify(log));
}
```

### Eventos a Logar
```typescript
// SEMPRE logar estes eventos
logSecurityEvent('file_upload', { fileName, size, type }, request);
logSecurityEvent('data_access', { resource, action, resourceId }, request);
logSecurityEvent('validation_error', { field, error, value }, request);
logSecurityEvent('rate_limit_exceeded', { ip, limit }, request);
```

## Prepara√ß√£o para Fase 2

### Estrutura de Auth
```typescript
// lib/auth.ts (prepara√ß√£o)
export interface AuthUser {
  id: string;
  email: string;
  empresaId: string;
  role: 'admin' | 'user' | 'viewer';
}

export function validateAuth(request: Request): AuthUser | null {
  // Implementar na Fase 2
  return null;
}
```

### Middleware de Auth
```typescript
// middleware/auth.ts (prepara√ß√£o)
export function requireAuth(handler: Function) {
  return async (request: Request) => {
    const user = validateAuth(request);
    if (!user) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    return handler(request, user);
  };
}
```

## Checklist de Seguran√ßa

### Valida√ß√µes Obrigat√≥rias
- [ ] **Uploads** validados por MIME e tamanho
- [ ] **Dados** sanitizados antes de salvar
- [ ] **Tenant** validado em todas as opera√ß√µes
- [ ] **Headers** de seguran√ßa configurados
- [ ] **Rate limiting** implementado
- [ ] **Logs** de seguran√ßa ativos
- [ ] **Auditoria** de opera√ß√µes cr√≠ticas
- [ ] **Estrutura** preparada para Fase 2