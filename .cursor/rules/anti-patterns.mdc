---
alwaysApply: true
description: "Anti-padr√µes e armadilhas comuns a evitar"
---

# üö´ Anti-Padr√µes e Armadilhas Comuns

## Prompts e Implementa√ß√£o
- ‚ùå **Prompts gigantes** ‚Üí c√≥digo acoplado e sem revis√£o
  ‚úÖ **Sempre dividir em PRD ‚Üí Arquitetura ‚Üí Implementa√ß√£o**

- ‚ùå **Funcionalidades m√∫ltiplas no mesmo PR**
  ‚úÖ **Garantir ciclo uma funcionalidade por vez**

- ‚ùå **Ignorar padr√µes j√° existentes**
  ‚úÖ **Validar arquitetura e metodologias antes de codar**

## C√≥digo e Estrutura
- ‚ùå **Arquivos muito longos** (>300 linhas)
  ‚úÖ **Dividir em arquivos menores e mais focados**

- ‚ùå **Fun√ß√µes muito longas** (>50 linhas)
  ‚úÖ **Dividir em fun√ß√µes menores com responsabilidade √∫nica**

- ‚ùå **Duplica√ß√£o de c√≥digo**
  ‚úÖ **Verificar se j√° existe funcionalidade similar e reutilizar**

- ‚ùå **Scripts em arquivos de c√≥digo**
  ‚úÖ **Usar scripts separados ou ferramentas apropriadas**

## Dados e Ambiente
- ‚ùå **Dados simulados em dev/prod**
  ‚úÖ **Usar dados simulados apenas para testes**

- ‚ùå **Sobrescrever .env sem confirma√ß√£o**
  ‚úÖ **Sempre perguntar antes de modificar arquivos de configura√ß√£o**

- ‚ùå **Hardcoded values**
  ‚úÖ **Usar vari√°veis de ambiente e constantes configur√°veis**

## Seguran√ßa e Qualidade
- ‚ùå **Expor informa√ß√µes sens√≠veis em logs**
  ‚úÖ **Implementar masking e sanitiza√ß√£o de dados sens√≠veis**

- ‚ùå **Valida√ß√£o apenas no frontend**
  ‚úÖ **Sempre validar no backend tamb√©m**

- ‚ùå **Commits de secrets**
  ‚úÖ **Usar .gitignore e vari√°veis de ambiente**

## Manutenibilidade
- ‚ùå **C√≥digo acoplado**
  ‚úÖ **Seguir princ√≠pios SOLID e inje√ß√£o de depend√™ncia**

- ‚ùå **Coment√°rios desnecess√°rios**
  ‚úÖ **C√≥digo autoexplicativo com nomes descritivos**

- ‚ùå **Mudan√ßas n√£o relacionadas no mesmo commit**
  ‚úÖ **Commits at√¥micos com uma mudan√ßa por vez**

## Exemplos de Corre√ß√£o de Anti-Padr√µes

### 1. Arquivo Muito Longo

#### ‚ùå Antes (arquivo com 400+ linhas)
```typescript
// user-service.ts - 450 linhas
export class UserService {
  // 50+ m√©todos misturados
  async createUser() { /* ... */ }
  async updateUser() { /* ... */ }
  async deleteUser() { /* ... */ }
  async validateEmail() { /* ... */ }
  async sendEmail() { /* ... */ }
  async logActivity() { /* ... */ }
  // ... mais 40+ m√©todos
}
```

#### ‚úÖ Depois (arquivos separados por responsabilidade)
```typescript
// user.service.ts - 80 linhas
export class UserService {
  async createUser() { /* ... */ }
  async updateUser() { /* ... */ }
  async deleteUser() { /* ... */ }
}

// email.service.ts - 60 linhas
export class EmailService {
  async sendEmail() { /* ... */ }
  async validateEmail() { /* ... */ }
}

// activity-logger.service.ts - 50 linhas
export class ActivityLoggerService {
  async logActivity() { /* ... */ }
}
```

### 2. Fun√ß√£o Muito Longa

#### ‚ùå Antes (fun√ß√£o com 80+ linhas)
```typescript
async processUserRegistration(userData: any) {
  // Valida√ß√£o
  if (!userData.email) throw new Error('Email required');
  if (!userData.password) throw new Error('Password required');
  if (userData.password.length < 8) throw new Error('Password too short');
  
  // Verifica√ß√£o de duplicata
  const existingUser = await this.userRepository.findByEmail(userData.email);
  if (existingUser) throw new Error('User already exists');
  
  // Hash da senha
  const hashedPassword = await bcrypt.hash(userData.password, 10);
  
  // Cria√ß√£o do usu√°rio
  const user = await this.userRepository.create({
    ...userData,
    password: hashedPassword
  });
  
  // Envio de email
  await this.emailService.sendWelcomeEmail(user.email);
  
  // Log da atividade
  await this.activityLogger.log('USER_CREATED', user.id);
  
  // Retorno
  return user;
}
```

#### ‚úÖ Depois (fun√ß√µes menores com responsabilidade √∫nica)
```typescript
async processUserRegistration(userData: CreateUserDto): Promise<User> {
  this.validateUserData(userData);
  await this.checkUserExists(userData.email);
  
  const hashedPassword = await this.hashPassword(userData.password);
  const user = await this.createUser({ ...userData, password: hashedPassword });
  
  await this.sendWelcomeEmail(user.email);
  await this.logUserCreation(user.id);
  
  return user;
}

private validateUserData(userData: CreateUserDto): void {
  if (!userData.email) throw new ValidationError('Email required');
  if (!userData.password) throw new ValidationError('Password required');
  if (userData.password.length < 8) throw new ValidationError('Password too short');
}

private async checkUserExists(email: string): Promise<void> {
  const existingUser = await this.userRepository.findByEmail(email);
  if (existingUser) throw new ConflictError('User already exists');
}

private async hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, 10);
}

private async createUser(userData: CreateUserData): Promise<User> {
  return this.userRepository.create(userData);
}

private async sendWelcomeEmail(email: string): Promise<void> {
  await this.emailService.sendWelcomeEmail(email);
}

private async logUserCreation(userId: string): Promise<void> {
  await this.activityLogger.log('USER_CREATED', userId);
}
```

### 3. Duplica√ß√£o de C√≥digo

#### ‚ùå Antes (l√≥gica duplicada)
```typescript
// user.controller.ts
@Post()
async createUser(@Body() userData: any) {
  if (!userData.email) throw new Error('Email required');
  if (!userData.password) throw new Error('Password required');
  // ... l√≥gica de cria√ß√£o
}

// admin.controller.ts
@Post()
async createAdmin(@Body() adminData: any) {
  if (!adminData.email) throw new Error('Email required');
  if (!adminData.password) throw new Error('Password required');
  // ... l√≥gica similar de cria√ß√£o
}
```

#### ‚úÖ Depois (l√≥gica centralizada)
```typescript
// validation.service.ts
export class ValidationService {
  validateEmail(email: string): void {
    if (!email) throw new ValidationError('Email required');
    if (!this.isValidEmailFormat(email)) throw new ValidationError('Invalid email format');
  }
  
  validatePassword(password: string): void {
    if (!password) throw new ValidationError('Password required');
    if (password.length < 8) throw new ValidationError('Password too short');
  }
  
  private isValidEmailFormat(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
}

// user.controller.ts
@Post()
async createUser(@Body() userData: CreateUserDto) {
  this.validationService.validateEmail(userData.email);
  this.validationService.validatePassword(userData.password);
  return this.userService.create(userData);
}

// admin.controller.ts
@Post()
async createAdmin(@Body() adminData: CreateAdminDto) {
  this.validationService.validateEmail(adminData.email);
  this.validationService.validatePassword(adminData.password);
  return this.adminService.create(adminData);
}
```

### 4. Hardcoded Values

#### ‚ùå Antes (valores fixos no c√≥digo)
```typescript
async sendEmail(to: string, subject: string, body: string) {
  const transporter = nodemailer.createTransporter({
    host: 'smtp.gmail.com',
    port: 587,
    secure: false,
    auth: {
      user: 'myapp@gmail.com',
      pass: 'mypassword123'
    }
  });
  
  if (body.length > 1000) {
    throw new Error('Body too long');
  }
  
  // ... resto da l√≥gica
}
```

#### ‚úÖ Depois (valores configur√°veis)
```typescript
// config/email.config.ts
export const emailConfig = {
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: parseInt(process.env.SMTP_PORT || '587'),
  secure: process.env.SMTP_SECURE === 'true',
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS
  }
};

export const emailLimits = {
  maxBodyLength: parseInt(process.env.EMAIL_MAX_BODY_LENGTH || '1000')
};

// email.service.ts
async sendEmail(to: string, subject: string, body: string) {
  this.validateEmailBody(body);
  
  const transporter = nodemailer.createTransporter(emailConfig);
  // ... resto da l√≥gica
}

private validateEmailBody(body: string): void {
  if (body.length > emailLimits.maxBodyLength) {
    throw new ValidationError('Email body too long');
  }
}
```