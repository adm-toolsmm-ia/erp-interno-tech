---
alwaysApply: true
description: "Diretrizes de seguran√ßa para desenvolvimento"
---

# üîí Diretrizes de Seguran√ßa

## Autentica√ß√£o e Autoriza√ß√£o
- **Sempre validar tokens JWT** em rotas protegidas
- **Implemente rate limiting** para APIs p√∫blicas
- **Use HTTPS** em produ√ß√£o sempre
- **Valide permiss√µes** em cada opera√ß√£o sens√≠vel
- **Implemente logout seguro** com invalida√ß√£o de tokens

## Valida√ß√£o de Dados
- **Valide TODOS os inputs** do usu√°rio
- **Use sanitiza√ß√£o** para prevenir XSS
- **Implemente valida√ß√£o server-side** mesmo com valida√ß√£o client-side
- **Use whitelist** em vez de blacklist para valida√ß√£o
- **Valide tipos e formatos** de dados

## Gerenciamento de Secrets
- **NUNCA commite secrets** no c√≥digo
- **Use vari√°veis de ambiente** para configura√ß√µes sens√≠veis
- **Implemente rota√ß√£o de secrets** regularmente
- **Use vaults de secrets** em produ√ß√£o
- **Nunca logue informa√ß√µes sens√≠veis**

## Seguran√ßa de APIs
- **Implemente CORS** adequadamente
- **Use headers de seguran√ßa** (HSTS, CSP, etc.)
- **Valide Content-Type** das requisi√ß√µes
- **Implemente timeout** para requisi√ß√µes
- **Use HTTPS** para todas as comunica√ß√µes

## Tratamento de Erros Seguro
- **Nunca exponha stack traces** em produ√ß√£o
- **Logue erros** sem expor informa√ß√µes sens√≠veis
- **Use c√≥digos de erro padronizados**
- **Implemente monitoramento** de tentativas de acesso suspeitas

## Dados Sens√≠veis
- **Criptografe dados sens√≠veis** em repouso
- **Use hash com salt** para senhas
- **Implemente PII masking** em logs
- **Siga LGPD/GDPR** para dados pessoais
- **Implemente auditoria** de acesso a dados sens√≠veis

## OWASP Top 10 Compliance

### 1. Broken Access Control
- **Implemente autoriza√ß√£o** em todas as rotas
- **Valide permiss√µes** em cada opera√ß√£o
- **Use princ√≠pio do menor privil√©gio**
- **Teste cen√°rios de acesso** n√£o autorizado

```typescript
// ‚úÖ Controle de acesso baseado em roles
@Controller('users')
@UseGuards(JwtAuthGuard, RolesGuard)
export class UsersController {
  @Get(':id')
  @Roles('admin', 'user')
  @UseInterceptors(OwnershipGuard)
  async getUser(@Param('id') id: string, @Request() req) {
    // Apenas admin ou o pr√≥prio usu√°rio pode acessar
    return this.usersService.findById(id);
  }
}

// ‚úÖ Middleware de autoriza√ß√£o
export const RolesGuard = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const userRoles = req.user?.roles || [];
    const hasRole = roles.some(role => userRoles.includes(role));
    
    if (!hasRole) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    next();
  };
};

// ‚úÖ Verifica√ß√£o de propriedade
export const OwnershipGuard = (req: Request, res: Response, next: NextFunction) => {
  const userId = req.params.id;
  const currentUserId = req.user?.id;
  const userRole = req.user?.role;
  
  if (userRole !== 'admin' && userId !== currentUserId) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  next();
};
```

### 2. Cryptographic Failures
- **Use HTTPS** sempre em produ√ß√£o
- **Criptografe dados sens√≠veis** com algoritmos seguros
- **Gere chaves** com entropia suficiente
- **Rotacione chaves** regularmente

```typescript
// ‚úÖ Criptografia segura para dados sens√≠veis
import crypto from 'crypto';

export class EncryptionService {
  private readonly algorithm = 'aes-256-gcm';
  private readonly keyLength = 32;
  
  encrypt(text: string): string {
    const key = crypto.randomBytes(this.keyLength);
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, key);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return `${key.toString('hex')}:${iv.toString('hex')}:${encrypted}`;
  }
  
  decrypt(encryptedText: string): string {
    const [keyHex, ivHex, encrypted] = encryptedText.split(':');
    const key = Buffer.from(keyHex, 'hex');
    const iv = Buffer.from(ivHex, 'hex');
    
    const decipher = crypto.createDecipher(this.algorithm, key);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}

// ‚úÖ Hash seguro para senhas
import bcrypt from 'bcrypt';

export class PasswordService {
  private readonly saltRounds = 12;
  
  async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, this.saltRounds);
  }
  
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }
}
```

### 3. Injection
- **Use prepared statements** para SQL
- **Valide e sanitize** todos os inputs
- **Use ORM** com prote√ß√£o contra injection
- **Implemente whitelist** para valida√ß√£o

```typescript
// ‚úÖ Prote√ß√£o contra SQL Injection com TypeORM
@Injectable()
export class UserService {
  async findUserByEmail(email: string): Promise<User> {
    // TypeORM protege automaticamente contra SQL injection
    return this.userRepository.findOne({
      where: { email: email }
    });
  }
}

// ‚úÖ Valida√ß√£o e sanitiza√ß√£o de entrada
import { IsEmail, IsString, Length, Matches } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  @IsString()
  email: string;
  
  @IsString()
  @Length(8, 50)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, {
    message: 'Password must contain uppercase, lowercase, number and special character'
  })
  password: string;
}

// ‚úÖ Sanitiza√ß√£o de HTML
import DOMPurify from 'isomorphic-dompurify';

export class InputSanitizer {
  static sanitizeHTML(input: string): string {
    return DOMPurify.sanitize(input, {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong'],
      ALLOWED_ATTR: []
    });
  }
  
  static sanitizeSQL(input: string): string {
    return input
      .replace(/[';--]/g, '') // Remove caracteres perigosos
      .replace(/union/gi, '') // Remove UNION
      .replace(/select/gi, '') // Remove SELECT
      .trim();
  }
}
```

### 4. Insecure Design
- **Implemente threat modeling** no design
- **Use padr√µes seguros** por padr√£o
- **Valide arquitetura** com especialistas
- **Documente decis√µes** de seguran√ßa

```typescript
// ‚úÖ Rate limiting para prevenir ataques
import rateLimit from 'express-rate-limit';

export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 5, // m√°ximo 5 tentativas por IP
  message: 'Too many login attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

// ‚úÖ Valida√ß√£o de entrada rigorosa
export class InputValidator {
  static validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email) && email.length <= 254;
  }
  
  static sanitizeInput(input: string): string {
    return input
      .replace(/[<>]/g, '') // Remove caracteres perigosos
      .trim()
      .substring(0, 1000); // Limita tamanho
  }
}
```

### 5. Security Misconfiguration
- **Desabilite recursos** desnecess√°rios
- **Configure headers** de seguran√ßa
- **Use HTTPS** em todos os ambientes
- **Monitore configura√ß√µes** regularmente

```typescript
// ‚úÖ Exemplo de headers de seguran√ßa
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
```

### 6. Vulnerable and Outdated Components
- **Audite depend√™ncias** regularmente
- **Mantenha bibliotecas** atualizadas
- **Use ferramentas** de scanning autom√°tico
- **Monitore CVE** para vulnerabilidades

```json
// package.json - Scripts de auditoria
{
  "scripts": {
    "audit": "npm audit",
    "audit:fix": "npm audit fix",
    "audit:ci": "npm audit --audit-level moderate",
    "check-updates": "npm outdated"
  }
}
```

### 7. Identification and Authentication Failures
- **Implemente MFA** quando poss√≠vel
- **Use rate limiting** para autentica√ß√£o
- **Proteja contra** ataques de for√ßa bruta
- **Implemente logout** seguro

```typescript
// ‚úÖ MFA obrigat√≥rio para usu√°rios cr√≠ticos
export class MFAService {
  async enableMFA(userId: string): Promise<{ qrCode: string; secret: string }> {
    const secret = speakeasy.generateSecret({
      name: `App Gest√£o Pessoal (${userId})`,
      issuer: 'App Gest√£o Pessoal'
    });
    
    await this.userRepository.update(userId, {
      mfaSecret: secret.base32,
      mfaEnabled: true
    });
    
    return {
      qrCode: secret.otpauth_url,
      secret: secret.base32
    };
  }
  
  async verifyMFA(userId: string, token: string): Promise<boolean> {
    const user = await this.userRepository.findById(userId);
    if (!user?.mfaSecret) return false;
    
    return speakeasy.totp.verify({
      secret: user.mfaSecret,
      encoding: 'base32',
      token: token,
      window: 2
    });
  }
}

// ‚úÖ Rate limiting para autentica√ß√£o
@Controller('auth')
export class AuthController {
  @Post('login')
  @UseGuards(ThrottlerGuard)
  @Throttle(5, 60) // 5 tentativas por minuto
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }
}
```

### 8. Software and Data Integrity Failures
- **Valide integridade** de dados
- **Use checksums** para arquivos
- **Implemente assinatura digital** quando necess√°rio
- **Monitore altera√ß√µes** n√£o autorizadas

### 9. Security Logging and Monitoring Failures
- **Implemente logging** de seguran√ßa
- **Monitore tentativas** de acesso suspeitas
- **Configure alertas** para eventos cr√≠ticos
- **Mantenha logs** por per√≠odo adequado

```typescript
// ‚úÖ Exemplo de logging de seguran√ßa
@Injectable()
export class SecurityLogger {
  logFailedLogin(ip: string, email: string): void {
    logger.warn('Failed login attempt', {
      ip,
      email,
      timestamp: new Date().toISOString(),
      event: 'AUTH_FAILED'
    });
  }
  
  logSuspiciousActivity(userId: string, activity: string): void {
    logger.error('Suspicious activity detected', {
      userId,
      activity,
      timestamp: new Date().toISOString(),
      event: 'SUSPICIOUS_ACTIVITY'
    });
  }
}
```

### 10. Server-Side Request Forgery (SSRF)
- **Valide URLs** de entrada
- **Use whitelist** de dom√≠nios permitidos
- **Implemente timeouts** para requests externos
- **Monitore requests** para dom√≠nios externos

## Auditoria de Depend√™ncias

### Ferramentas Obrigat√≥rias
- **npm audit** para vulnerabilidades conhecidas
- **Snyk** para scanning cont√≠nuo
- **Dependabot** para atualiza√ß√µes autom√°ticas
- **Renovate** para gerenciamento de depend√™ncias

```yaml
# .github/dependabot.yml
version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
    reviewers:
      - "security-team"
```

### Checklist de Seguran√ßa

#### Configura√ß√£o Inicial
- [ ] **OWASP Top 10** mapeado e mitigado
- [ ] **Headers de seguran√ßa** configurados
- [ ] **HTTPS** habilitado em todos os ambientes
- [ ] **Rate limiting** implementado

#### Desenvolvimento
- [ ] **Valida√ß√£o de entrada** em todas as APIs
- [ ] **Autoriza√ß√£o** verificada em cada opera√ß√£o
- [ ] **Logs de seguran√ßa** implementados
- [ ] **Dados sens√≠veis** mascarados em logs

#### Deploy e Monitoramento
- [ ] **Auditoria de depend√™ncias** automatizada
- [ ] **Scanning de vulnerabilidades** no CI/CD
- [ ] **Monitoramento** de tentativas de ataque
- [ ] **Plano de resposta** a incidentes definido