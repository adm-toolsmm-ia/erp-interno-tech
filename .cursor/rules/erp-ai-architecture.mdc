---
globs: *.ts,*.tsx,*.js,*.jsx
description: "Arquitetura de IA e embeddings para o ERP"
---

# ü§ñ ERP AI Architecture ‚Äî ERPInternoTech

## Arquitetura de IA Obrigat√≥ria

### Embeddings com pgvector
```typescript
// SEMPRE usar pgvector para embeddings
export interface DocumentEmbedding {
  id: string;
  documentoId: string;
  versaoId?: string;
  embedding: number[]; // 1536 dimens√µes para OpenAI
  provider: 'openai' | 'local';
  dims: number;
  createdAt: Date;
}

// Configura√ß√£o do Supabase com pgvector
export const supabaseConfig = {
  url: process.env.SUPABASE_URL!,
  anonKey: process.env.SUPABASE_ANON_KEY!,
  serviceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY!,
  // Habilitar pgvector
  dbConfig: {
    extensions: ['vector']
  }
};
```

### Gera√ß√£o de Embeddings
```typescript
// SEMPRE gerar embeddings para documentos
export async function generateEmbedding(
  content: string, 
  provider: 'openai' | 'local' = 'openai'
): Promise<number[]> {
  if (provider === 'openai') {
    const response = await fetch('https://api.openai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        input: content,
        model: 'text-embedding-3-small' // 1536 dimens√µes
      })
    });
    
    const data = await response.json();
    return data.data[0].embedding;
  }
  
  // Implementar gera√ß√£o local se necess√°rio
  throw new Error('Local embedding generation not implemented');
}
```

### Armazenamento de Embeddings
```typescript
// SEMPRE salvar embeddings no banco
export async function saveDocumentEmbedding(
  documentoId: string,
  versaoId: string,
  content: string,
  empresaId: string
): Promise<DocumentEmbedding> {
  const embedding = await generateEmbedding(content);
  
  const embeddingRecord = await prisma.documentoEmbedding.create({
    data: {
      documentoId,
      versaoId,
      embedding: embedding, // pgvector automaticamente converte
      provider: 'openai',
      dims: 1536
    }
  });
  
  // Logar custo e lat√™ncia
  await logEmbeddingMetrics({
    documentoId,
    versaoId,
    empresaId,
    provider: 'openai',
    dims: 1536,
    cost: calculateEmbeddingCost(content.length),
    latency: Date.now() - startTime
  });
  
  return embeddingRecord;
}
```

### Busca Sem√¢ntica
```typescript
// SEMPRE implementar busca sem√¢ntica
export async function semanticSearch(
  query: string,
  empresaId: string,
  filters?: {
    projetoId?: string;
    clienteId?: string;
    categoriaId?: string;
  }
): Promise<SearchResult[]> {
  const queryEmbedding = await generateEmbedding(query);
  
  // Busca usando pgvector
  const results = await prisma.$queryRaw`
    SELECT 
      d.id,
      d.titulo,
      d.storageKey,
      d.contentType,
      d.createdAt,
      p.nome as projetoNome,
      c.razaoSocial as clienteNome,
      1 - (de.embedding <=> ${JSON.stringify(queryEmbedding)}::vector) as similarity
    FROM documentos d
    JOIN documento_embeddings de ON d.id = de.documentoId
    LEFT JOIN projetos p ON d.projetoId = p.id
    LEFT JOIN clientes c ON d.clienteId = c.id
    WHERE d.empresaId = ${empresaId}
      AND d.deletedAt IS NULL
      AND de.embedding <=> ${JSON.stringify(queryEmbedding)}::vector < 0.8
    ORDER BY similarity DESC
    LIMIT 20
  `;
  
  return results as SearchResult[];
}
```

## Logging de IA

### M√©tricas de Embeddings
```typescript
// SEMPRE logar m√©tricas de IA
export interface EmbeddingMetrics {
  documentoId: string;
  versaoId?: string;
  empresaId: string;
  provider: string;
  dims: number;
  cost: number;
  latency: number;
  timestamp: string;
}

export async function logEmbeddingMetrics(metrics: EmbeddingMetrics) {
  console.log(JSON.stringify({
    level: 'ai_metrics',
    event: 'embedding_generated',
    ...metrics
  }));
  
  // Salvar no banco para an√°lise
  await prisma.aiMetrics.create({
    data: {
      empresaId: metrics.empresaId,
      event: 'embedding_generated',
      provider: metrics.provider,
      cost: metrics.cost,
      latency: metrics.latency,
      metadata: {
        documentoId: metrics.documentoId,
        versaoId: metrics.versaoId,
        dims: metrics.dims
      }
    }
  });
}
```

### C√°lculo de Custos
```typescript
// SEMPRE calcular custos de IA
export function calculateEmbeddingCost(textLength: number): number {
  // OpenAI text-embedding-3-small: $0.00002 per 1K tokens
  const tokens = Math.ceil(textLength / 4); // Aproxima√ß√£o: 4 chars = 1 token
  const costPer1K = 0.00002;
  return (tokens / 1000) * costPer1K;
}

export function calculateCompletionCost(inputTokens: number, outputTokens: number): number {
  // OpenAI gpt-4: $0.03 input, $0.06 output per 1K tokens
  const inputCost = (inputTokens / 1000) * 0.03;
  const outputCost = (outputTokens / 1000) * 0.06;
  return inputCost + outputCost;
}
```

## Versionamento de Embeddings

### Sincroniza√ß√£o com Documentos
```typescript
// SEMPRE versionar embeddings com documentos
export async function updateDocumentEmbeddings(
  documentoId: string,
  novaVersao: number,
  content: string,
  empresaId: string
) {
  // Gerar embedding para nova vers√£o
  const embedding = await generateEmbedding(content);
  
  // Salvar nova vers√£o do embedding
  await prisma.documentoEmbedding.create({
    data: {
      documentoId,
      versaoId: novaVersao.toString(),
      embedding,
      provider: 'openai',
      dims: 1536
    }
  });
  
  // Manter hist√≥rico de vers√µes anteriores
  // N√£o deletar embeddings antigos para rollback
}
```

### Rollback de Embeddings
```typescript
// SEMPRE permitir rollback de embeddings
export async function rollbackDocumentEmbedding(
  documentoId: string,
  versaoAlvo: number
) {
  // Marcar vers√£o atual como rollback
  await prisma.documentoEmbedding.updateMany({
    where: {
      documentoId,
      versaoId: { not: versaoAlvo.toString() }
    },
    data: {
      rollback: true
    }
  });
  
  // Ativar vers√£o alvo
  await prisma.documentoEmbedding.updateMany({
    where: {
      documentoId,
      versaoId: versaoAlvo.toString()
    },
    data: {
      rollback: false
    }
  });
}
```

## Prompts Padronizados

### Biblioteca de Prompts
```typescript
// SEMPRE usar prompts padronizados
export const PROMPTS = {
  // An√°lise de documentos
  ANALYZE_DOCUMENT: `
    Analise o seguinte documento e extraia:
    1. Tipo de documento
    2. Assunto principal
    3. Palavras-chave relevantes
    4. Categoria sugerida
    5. Resumo executivo
    
    Documento: {content}
  `,
  
  // Classifica√ß√£o de documentos
  CLASSIFY_DOCUMENT: `
    Classifique o documento nas seguintes categorias:
    - Proposta Comercial
    - Contrato
    - Ata de Reuni√£o
    - Relat√≥rio T√©cnico
    - Or√ßamento
    - Outros
    
    Documento: {content}
    Resposta: Apenas o nome da categoria
  `,
  
  // Gera√ß√£o de resumos
  GENERATE_SUMMARY: `
    Gere um resumo executivo do seguinte documento:
    - M√°ximo 3 par√°grafos
    - Foco nos pontos principais
    - Linguagem t√©cnica apropriada
    
    Documento: {content}
  `
};
```

### Context Engineering
```typescript
// SEMPRE usar contexto modular
export function buildContext(empresaId: string, modulo: string): string {
  const contextModules = {
    projeto: `
      Contexto: M√≥dulo de Projetos
      Empresa: ${empresaId}
      Status dispon√≠veis: Prospec√ß√£o, Em andamento, Conclu√≠do, Cancelado, Pausado
      Campos obrigat√≥rios: assunto, dataEntrada, clienteId
    `,
    cliente: `
      Contexto: M√≥dulo de Clientes
      Empresa: ${empresaId}
      Valida√ß√µes: CNPJ obrigat√≥rio, raz√£o social √∫nica por empresa
      Relacionamentos: Projetos, Documentos, Representantes
    `,
    documento: `
      Contexto: M√≥dulo de Documentos
      Empresa: ${empresaId}
      Versionamento: Sempre criar nova vers√£o, manter hist√≥rico
      Embeddings: Gerar automaticamente para busca sem√¢ntica
    `
  };
  
  return contextModules[modulo] || '';
}
```

## Checklist de IA

### Implementa√ß√µes Obrigat√≥rias
- [ ] **pgvector** configurado no Supabase
- [ ] **Embeddings** gerados automaticamente
- [ ] **Busca sem√¢ntica** implementada
- [ ] **M√©tricas de IA** logadas
- [ ] **Custos** calculados e monitorados
- [ ] **Versionamento** de embeddings
- [ ] **Rollback** de embeddings
- [ ] **Prompts** padronizados
- [ ] **Contexto modular** implementado